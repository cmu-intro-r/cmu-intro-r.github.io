[["preface.html", "An Introduction to R Preface", " An Introduction to R Peter E. Freeman (Department of Statistics &amp; Data Science, Carnegie Mellon University) July 2024 Preface The purpose of this “book” is to provide students in our camps and certification courses a brief and basic introduction to the R programming language, so that they may “hit the ground running” when they begin participating in our programs. The material presented here corresponds roughly to that I presented during the first three-to-four weeks of the course 36-350, Statistical Computing, when I taught it last in Fall 2020. If you have any questions or concerns, or if you find any typos(!), please contact me at pfreeman AT cmu DOT edu. Peter Freeman July 2024 "],["getting-started.html", "1 Getting Started 1.1 Installing R and RStudio 1.2 The RStudio Layout 1.3 What is R?", " 1 Getting Started 1.1 Installing R and RStudio These instructions are current as of April 2024. To download R and RStudio, first go to this web site. To the left is a button that says “Download and Install R”. Click on that, then go to the top box and select the appropriate download link (for macOS or Windows). If Windows, then click on “base” and then on “Download R-4.3.3 for Windows”. (Download and follow the instructions to install R.) If Mac, click on the appropriate package name, depending on whether you have an Apple Silicon- or Intel-based Mac. (Download and follow the instructions.) To the right is a button that says “Download RStudio Desktop…” Assuming your R installation was successful, click on this to download and install RStudio. (As before, follow the instructions…installation should be seamless.) 1.2 The RStudio Layout When you first open RStudio, it should look something like this: At first, the most important elements of RStudio to be aware of are the Console pane (shown at left here); and the Files, Packages, and Help panes (shown at lower right) The Console pane is where you will type commands (starting in the next section, What is R?) The Files pane shows where you are within your computer’s file system. You can click directly on the folders within this pane to move downwards within your file system, or, if you need to go to a folder not directly under Home, you can click on the three dots “…” (to the right of Home) and that will open your system’s folder navigator…click through to the folder you want, and select “Open” (or the equivalent). It is imperative that you know where, e.g., the files you want to load into RStudio are located once you download them, and that you know how to move to the folder in which the files are located! Once you are in the folder you want to work in, you should click on More (next to the gear icon) and click on Set as Working Directory. The Packages pane contains a button labeled Install: click on this button when and if you need to install a package that is not currently in your local installation of R. The Help pane contains a search field to upper right…type in a function name (e.g., mean) and the documentation will appear. Alternatively, you can type, e.g., ?mean in the Console pane. All good? You are ready to get started with R! 1.3 What is R? NOTE: throughout this “book”, code output is not shown. It is assumed that you will type all the code into the Console in RStudio, both to actively engage with the material and to actually see the output. We start this class as any class of this type should be started. Assuming you’ve fired up RStudio and you’ve meandered your way to the console, go to the prompt and type the following: print(&quot;Hello, World!&quot;) So, to get to the first question you may have: why is there a “[1]” in the output? It denotes that on this line of output, the first displayed value is the first output value overall. Compare this to the output you get when you sample 50 values from a standard normal distribution: rnorm(50) From the R FAQ: “2.1 What is R? R is a system for statistical computation and graphics. It consists of a language plus a run-time environment with graphics, a debugger, access to certain system functions, and the ability to run programs stored in script files. The design of R has been heavily influenced by two existing languages: Becker, Chambers &amp; Wilks’ S (see What is S?) and Sussman’s Scheme. Whereas the resulting language is very similar in appearance to S, the underlying implementation and semantics are derived from Scheme… The core of R is an interpreted computer language which allows branching and looping as well as modular programming using functions. Most of the user-visible functions in R are written in R. It is possible for the user to interface to procedures written in the C, C++, or FORTRAN languages for efficiency. The R distribution contains functionality for a large number of statistical procedures. Among these are: linear and generalized linear models, nonlinear regression models, time series analysis, classical parametric and nonparametric tests, clustering and smoothing. There is also a large set of functions which provide a flexible graphical environment for creating various kinds of data presentations…” R has a home page. It is free software distributed under a GNU-style copyleft, and an official part of the GNU project (“GNU S”). A key phrase above is “[t]he core of R is an interpreted computer language.” This means that instructions are executed directly when typed into the console of RStudio. For instance: 666 R doesn’t know necessarily what to do with this input of type “double,” so it outputs it to the screen. (If you input something of unknown type, like an uninitialized variable, you’d get an error instead.) You have to help R along, by, e.g., explicitly telling it you want to assign the value 666 to a variable: x &lt;- 666 x typeof(x) There are other ways to output the value of the variable x, such as print(x) cat(&quot;x =&quot;,x,&quot;\\n&quot;) As you can see (and will see again later), the latter is more flexible than the former. Standard mathematical operations include Operation Name + addition - subtraction * multiplication / division ^ exponentiation %% modulus (i.e., remainder) %/% division with (floored) integer round-off Try the following: x &lt;- 2 y &lt;- 3 x*y x/y x^y y%/%x To remove the variable x from global environment: x &lt;- 666 rm(x) gc() The latter function’s name stands for “garbage collection.” Garbage collection is a means by which to give freed memory back to your computer for it to use, and thus is only really important if you are removing variables that are using lots of memory (e.g., large matrices). "],["vectors-and-lists.html", "2 Vectors and Lists 2.1 All About Vectors 2.2 All About Lists 2.3 Handy Vector Functions 2.4 Control-Flow Constructs 2.5 Loops", " 2 Vectors and Lists 2.1 All About Vectors As a reminder: code output is not shown. It is assumed that you will type all the code into the Console in RStudio, both to actively engage with the material and to actually see the output. Atomic vectors are homogeneous, i.e., all elements of the vectors are of the same type. The types of atomic vectors (or just vectors) are: Type Description double double-precision floating-point numbers (8 bytes per element) integer integer numbers (4 bytes per element) logical TRUE and FALSE character individual strings (at 1 byte per individual character within each string) complex and raw (not covered here) Note: the integer and double types are collectively (and at times confusingly) dubbed numeric. (Confusingly because one can cast to a numeric type, which is equivalent to casting to double.) Let’s show the various ways in which one can initialize a vector (in this case, of integers) of length five: Command Comment x &lt;- c(0,0,0,0,0) c = “collection” or “container” x &lt;- rep(0,5) rep = “repeat” x &lt;- vector(\"integer\",5) x &lt;- integer(5) x &lt;- seq(1,5,by=1) seq = “sequence” x &lt;- 1:5 steps by 1 Note that one can use all six of these functions to initialize numeric vectors, and the first four to initialize those of mode logical or character, as with, e.g., vector(&quot;logical&quot;,5) character(5) Note: there is no such thing as a “scalar” in R, i.e., x &lt;- 1 defines a double-precision vector of length 1. To determine the type of a vector: x &lt;- c(1,0,3,2) typeof(x) To determine the number of elements in a vector: length(x) To display the \\(n^{\\rm th}\\) element of a vector (here, the first one…and note that R counts from 1, not 0): x[1] To explicitly cast from one type to another: as.character(x) as.logical(x) To sort a vector in ascending order, and to retrieve the sorted vector indices: x sort(x) order(x) To reverse the order of the elements in a vector: rev(x) If you apply a relational operator to a vector, the output will be a logical vector: set.seed(101) x &lt;- rnorm(10) x &gt; 0 VERY IMPORTANT: if you apply a logical vector of length \\(n\\) to a vector of length \\(n\\), then only the elements of the second vector associated with the value TRUE will be displayed! For instance: x x[x&gt;0] The output from relational operators can be combined using the logical and operator &amp; or the logical or operator |: y &lt;- x&gt;0 &amp; x&lt;0.5 x[y] y &lt;- x&lt;0 | x&gt;0.5 x[y] To invert a logical vector, use the ! operator: x[!y] To determine how many values in your vector satisfy a condition, combine one or more relational operators with the sum() function: sum(x&gt;-0.5&amp;x&lt;0) To determine which elements of the original vector satisfy a condition, combine one or more relational operators with the which() function: which(x&gt;-0.5&amp;x&lt;0) Another means by which to subset a vector is to apply the output of the which() function. Note how adding a minus sign changes the output! w &lt;- which(x&lt;0) x[w] x[-w] As a final note: NA means “Not Available” and is the preferred way in R to denote missing data NaN means “Not a Number” and denotes, e.g, 0/0 Inf means “Infinite” and denotes, e.g., 1/0 To determine whether vector elements are, e.g., NA, we can use the is.na(), is.nan(), and/or is.infinite() functions. Each returns a logical vector. x &lt;- c(1,NA,3) is.na(x) x[!is.na(x)] 2.1.1 All About Vectors: Lab Exercises Please download and work through the following R Markdown file: vectors.Rmd The solutions are provided here. 2.2 All About Lists As can be seen above, a list is not an atomic entity; it may be thought of as a (perhaps heterogeneous) collection of atomic vectors: x &lt;- list(1:5,c(&quot;a&quot;,&quot;b&quot;)) x A list in R is like a dictionary in Python. For reasons that will become apparent soon, it is perhaps best to think of a list as a “table,” with each separate vector in the list being a “column” within that table. (Yes, the number of rows can vary from column to column, but work with me here.) To access a “column,” you use “double-bracket” notation: x[[2]] To access a particular “row” in a given column, you can tack on its number: x[[1]][3] Dealing with double brackets can be tiresome. We can assign names to each of the list elements as follows: names(x) &lt;- c(&quot;a&quot;,&quot;b&quot;) x We can also change the name of any one of the elements like so: names(x)[1] &lt;- c(&quot;c&quot;) x When you initialize a list, you can name each of the vectors and then use the names to access list elements. Note the use of the dollar sign in the third line below; it is a useful shorthand. x &lt;- list(u=1:5,v=c(&quot;a&quot;,&quot;b&quot;)) x[[&quot;u&quot;]][3] x$u[3] A data frame is a list whose entries all have the same number of elements. x &lt;- data.frame(u=1:2,v=c(&quot;a&quot;,&quot;b&quot;),w=c(TRUE,FALSE)) x Note that when we output a data frame, row numbers are added. Are we sure this is a list? Yes…if we check the variable type: typeof(x) class(x) A matrix may be thought of as a data frame whose columns are all vectors of the same type. However, operations applied to a matrix are fundamentally different from those applied to a list. x &lt;- matrix(1:6,nrow=2) x      # the matrix filled column-by-column (column-major order) x[[1]] # doesn&#39;t work like you&#39;d think it should x[2,1] # works: row first, then column 2.2.1 All About Lists: Lab Exercises Please download and work through the following R Markdown file: lists.Rmd The solutions are provided here. 2.3 Handy Vector Functions A vector, like a list, can have names and attributes: x &lt;- c(a=1,b=2,c=3) attr(x,&quot;Creator&quot;) = &quot;Peter Freeman&quot; x If you want to, e.g., strip the names and attributes off, even temporarily, you can use as.vector(): as.vector(x) If you have a list, and want to concatenate the contents of each list element into a single vector, do not use as.vector(), but rather use unlist(): x &lt;- list(c(&quot;a&quot;,&quot;b&quot;),1:3) x unlist(x)  # note: casting occurs to make the vector elements a single type! You’ve learned about sort(). Here we will show an example of why order() is also important. order() returns a numeric vector showing vector elements and not vector values (which is what sort() returns): x &lt;- c(5,3,7,1) # the 4th element is the smallest, then the 2nd element, then the 1st, then the 3rd order(x) Now, let’s say you have a pair of vectors of equal length (e.g., two columns in a data frame), and you wish to sort one vector but keep the association between the vectors intact: x &lt;- c(9,5,7,6) # we have four pairs: 9 with 1, 5 with 2, 7 with 3, 6 with 4 y &lt;- 1:4 sort(x) # the association between vectors is broken sort(y) o &lt;- order(x) x[o]    # the association between vectors remains intact y[o] In short: sort() is useful when sorting one vector, and order() is useful for sorting an associated group of vectors (read: a data frame) based on the entries in one of vectors (read: a column). Let’s say you have a vector that has many repeated values (e.g., the index of a datum’s leaf in a classification tree). To determine the set of unique values, use the unique() function: set.seed(999) x &lt;- sample(c(3,6,12,44),100,replace=TRUE) # assume we don&#39;t actually know the input values unique(x) As you can see, the values are sorted according to when they first appeared in the vector. So sometimes it is useful to redirect the output from unique() to the sort() function: sort(unique(x)) If you not only want to see what the unique values are, but how many times each occurred, use a table(): table(x) # this will actually sort the values for you, unlike unique To follow up on a previous topic: the output of table() is of class table, which creates a structure that includes the data frequencies, uses the data values as names, and carries around attributes (e.g., dim, the number of data values). As a reminder, if you just want the frequencies… as.vector(table(x)) Perhaps you wish to bin the values in a vector. You can do this with a combination of table() and the function findInterval(). For the latter, you pass in a vector of bin boundaries and a data vector and what comes out is a vector of bin numbers. For instance: x &lt;- 1:10 findInterval(x,c(3,7)) # [1,3) -&gt; bin 0, [3,7) -&gt; bin 1, [7,10] -&gt; bin 2 As stated, it can be useful to summarize this output in a table. For instance, if we sample 10,000 data from a standard normal, we expect about 68.27% of the values to lie between -1 and 1. set.seed(666) x &lt;- rnorm(10000) table(findInterval(x,c(-1,1))) Pretty good! Let’s define two vectors: u &lt;- c(1:5,5,5) v &lt;- 3:7 First, we can apply set operations to these vectors. For instance, to merge the vectors: union(u,v) # NOTE: this only shows the *unique* values in the union...the 5 is not replicated! And if there is a union, there must be an intersect(ion): intersect(u,v) # NOTE: as above, only the *unique* values are shown What values are in the vector u that are not in the vector v? setdiff(u,v) # asymmetric: setdiff(v,u) gives different answer! Do the vectors contain the same values (regardless of the number of times values are replicated)? setequal(u,v) setequal(u[-(1:2)],v[1:3]) There are two principal ways to determine if elements of one vector are contained in another. is.element(u,v): this returns a logical vector. The \\(i^{\\rm th}\\) element of this vector is TRUE if u[i] is an element of v, and FALSE otherwise. match(u,v): this returns a numeric vector. The \\(i^{\\rm th}\\) element of this vector is NA by default if u[i] is not an element of v. Otherwise, it is the index of the element of v that provides the first match to u[i]. u v is.element(u,v) # the binary operator `%in%` is equivalent: `u %in% v` match(u,v) 2.3.1 Handy Vector Functions: Lab Exercises Please download and work through the following R Markdown file: vector_functions.Rmd The solutions are provided here. 2.4 Control-Flow Constructs The phrase “control-flow constructs” is one that R’s creators use to denote if and while and such. You can find a full list of control-flow constructs by typing ?Control in the RStudio console. The constructs are among the reserved words in R’s command-line parser (meaning you cannot use them as variable names). You can find a list of reserved words by typing ?Reserved in the console. xx &lt;- 2 if &lt;- 2 (Important note: if you want to knit an R Markdown file which has a buggy code chunk, add error=TRUE in the first line of the chunk.) Here are basic examples of the use of the if-else construct: x &lt;- 2 if ( x == 2 ) print(x)   # one line, no curly brackets if ( x == 2 ) {         # use curly brackets to enclose multiple commands over several lines   print(x) } if ( x == 2 ) {          # same idea, but now with an &quot;else&quot; thrown in   print(-x) } else {   print(x) } (Note the ==, which is a relational operator, and returns TRUE or FALSE. Use of a single = will lead to an exception being thrown.) An if-else construct will evaluate until the first time the quantity in parentheses evaluates to TRUE. Below, x = 2 and x &gt; 0, but foo is not printed. if ( x == 2 ) {   print(-x) } else if ( x &gt; 0 ) {   print(&quot;foo&quot;) } else {   print(&quot;bar&quot;) } One can combine conditions within an if statement using &amp;&amp; (for “and”) or || (for “or”). IMPORTANT: the difference between, e.g., &amp;&amp; and &amp; is that the latter returns a logical vector that can have a length greater than 1 and the former returns a logical vector of length 1. u &lt;- c(TRUE,FALSE,TRUE) v &lt;- c(TRUE,TRUE,FALSE) u &amp; v u &amp;&amp; v u &amp;&amp; v only does a comparison between the first elements of u and v and ignores any subsequent elements. Long story short: if you use &amp;&amp; in an if statement, make sure what is on either side of the &amp;&amp; are vectors of length one. Otherwise you may not get the behavior you expect when you run your code. A compressed version of an if-else construct is provided by the ifelse() function: ifelse(test,yes,no) # don&#39;t run this! which means “if the object test returns TRUE, do whatever is specified by yes, otherwise do whatever is specified by no.” For example: x &lt;- 2 ifelse(x==2,TRUE,FALSE) 2.4.1 Control-Flow Constructs: Lab Exercises Please download and work through the following R Markdown file: control_flow.Rmd The solutions are provided here. 2.5 Loops A for() loop repeatedly runs a block of code while (usually) incrementing the value of a counter variable. Its typical structure is for ( &lt;var name&gt; in &lt;min counter value&gt;:&lt;max counter value&gt; ) { &lt;do stuff&gt; } Here we compute \\(x^2\\) for \\(x \\in [1,10]\\): x.sq &lt;- rep(NA,10) for ( ii in 1:10 ) {  # Why ii and not i? Easier to search for when debugging large code bases.   x.sq[ii] &lt;- ii^2 } x.sq NOTE: one should utilize vectorization when one can. For instance, if \\(x\\) is an \\(n\\)-element vector, and \\(y\\) is an \\(n\\)-element vector, then, e.g., \\(x+y\\) is an \\(n\\)-element vector that contains the sums of the first elements and of the second elements, etc. In other words, one does not have to loop over vector indices to apply operations to each element. The above example is thus purely academic; one would really want to code this as x.sq = (1:10)^2. A decently good rule to follow is, when in doubt, code a for() loop first, get your full code base working, then see where you might be able to apply vectorization (while always checking that your output is unchanged as you update code). In the example above, the counter vector is 1:10. You can specify this in other ways: for ( ii in seq(1,10,by=1) ) {  # More general than 1:10; allows steps of size &gt; 1.   x.sq[ii] &lt;- ii^2 } x.sq Or you can specify that you are to step along each of the indices of \\(x\\) in order: for ( ii in seq_along(x.sq) ) {  # No need to specify bounds; good if you change the length of x.sq   x.sq[ii] &lt;- ii^2 } x.sq The counter vector need not be numeric. str.vec = c(&quot;Pirates&quot;,&quot;Steelers&quot;,&quot;Penguins&quot;) for ( str in str.vec ) {   not &lt;- &quot;&quot;   if ( str == &quot;Pirates&quot;) not &lt;- &quot;not&quot;   cat(&quot;The&quot;,str,&quot;will&quot;,not,&quot;win the championship this year.\\n&quot;) } A while() loop repeatedly runs a block of code until some condition is no longer true. The usual structure here is while ( &lt;condition&gt; == TRUE ) { &lt;do stuff and possibly change condition to FALSE&gt; } For example: continue &lt;- TRUE x &lt;- 1 while ( continue == TRUE ) {  # the &quot;== TRUE&quot; is actually not necessary here   if ( x &lt;= 5 ) {     cat(x,&quot; &quot;)   } else {     continue &lt;- FALSE   }   x &lt;- x+1 } When should you use for() and when should you use while()? for() is good when you know what indices you will iterate over in advance while() is good when you know the condition that needs to be fulfilled for the looping to stop, but you don’t know when it will be fulfilled (so, e.g., the example on the last slide is not necessarily the best example to display for while(), since we knew we were going to increment from \\(x = 1\\) to \\(x = 5\\) in advance) NOTE: every for() loop can be replaced with a while() loop, but not vice-versa. If at some point in a loop you want to skip the remaining commands and return to the loop’s beginning, use next. If at some point in a loop you want to skip the remaining commands and exit the loop entirely, use break. for ( ii in 1:10 ) {   if ( ii &gt;= 6 ) break   if ( ii &gt;= 6 ) print(&quot;oops!&quot;)   if ( ii &gt;= 3 ) next   print(ii) } ii The loop skipped the final print() statement when ii \\(\\geq 3\\), hence we only see the numbers 1 and 2 output initially, and then we exited the loop when ii = 6 (we know this because “oops!” was never printed). One can, in principle, create an infinite loop that will continue until a break is issued: while ( TRUE ) { # Because TRUE == TRUE, always   input &lt;- readline(&quot;Name the best prof at CMU!&quot;)   if ( input == &quot;Freeman&quot; ) break   print(&quot;Try again.&quot;) } NOTE: a repeat block will behave the same way. See ?Control for more details. 2.5.1 Loops: Lab Exercises Please download and work through the following R Markdown file: loops.Rmd The solutions are provided here. "],["strings.html", "3 Strings 3.1 Basic String Functions 3.2 Regular Expressions 3.3 String Extraction and Replacement", " 3 Strings 3.1 Basic String Functions A string is a sequence of characters that are bound together, where a character is a symbol is a written language. In R, a string is of mode (or class) character and is bounded by quotes (either single or double): mode(&quot;r&quot;) class(&#39;r&#39;) Two notes: R helps keep your life complicated via two similar but not identical concepts: mode and class. Feel free to lose time trying to fully internalize how they differ. Double quotes are preferable, because then one can use single quotes as apostrophes in strings. There are special symbols that one uses for tabbing (“) and for forcing line breaks (”“): message &lt;- &quot;To-do list for students:\\n\\tHomework\\n\\tLabs\\n\\tFinal Project&quot; cat(message) To count the number of characters in a string, use the function nchar() (as opposed to length(), which counts the number of elements in a vector). To illustrate the difference, let’s define a vector of strings: str.vec &lt;- c(&quot;I&quot;,&quot;will&quot;,&quot;master&quot;,&quot;R&quot;) nchar(str.vec) length(str.vec) Potentially useful functions to use with vectors that we have not seen previously include: head(str.vec,2)       # display/extract the first two elements tail(str.vec,2)       #                 the last two elements toupper(str.vec)      # change all characters to upper case tolower(str.vec)      # change all characters to lower case Let’s define another string vector: candidates &lt;- c(&quot;Trump&quot;,&quot;Clinton&quot;,&quot;Johnson&quot;,&quot;Stein&quot;) If you, for instance, want to extract the first two letters of each name, you can use substr(): substr(candidates,1,2) If you want to extract the last two letters, utilize nchar(), since the total number of letters in each name is different: substr(candidates,nchar(candidates)-1,nchar(candidates)) To replace the last two letters with something else, substr(candidates,nchar(candidates)-1,nchar(candidates)) &lt;- &quot;:)&quot; candidates If there is a mismatch between the number of characters to replace (here: 2) and the number of characters in the replacement string (here: 6), R will simply truncate. Here, that means only the first two characters in the replacement string are used. substr(candidates,nchar(candidates)-1,nchar(candidates)) &lt;- &quot;:(:|:)&quot; candidates 3.1.1 Basic String Functions: Lab Exercises Please download and work through the following R Markdown file: string_functions.Rmd The solutions are provided here. 3.2 Regular Expressions Regexes are specially constructed strings that allow for flexible pattern matching. The rules for constructing regexes are independent of R; you may already know them. (But even then, reviewing them cannot hurt. Too much.) Literals: strings we want to literally match (e.g., “fly”, which does not match with “flies”) “Or”: for more flexible matching; if you want to match “fly” or “flies”, use “fly|flies”. Concatenation: “(a|b) (c|d)” is a concatenation of two regexes…use this if you want to find “a” or “b” followed by a space followed by “c” or “d”. Here, the parantheses define the group of possible literals that we are trying to match. The grep() function carries out matching. str.vec &lt;- c(&quot;fly&quot;,&quot;Fly&quot;,&quot;flies&quot;) grep(&quot;fly&quot;,str.vec)               # grep is case-sensitive! This returns vector element(s) for match(es). grep(&quot;fly&quot;,str.vec,value=TRUE)    #                         This returns the vector value(s) for match(es). grep(&quot;fl&quot;,str.vec,value=TRUE) str.vec &lt;- c(&quot;time flies&quot;,&quot;fruit fly&quot;,&quot;fruit flies&quot;) grep(&quot;(time|fruit) flies&quot;,str.vec,value=TRUE) grep(&quot;fruit (time|times)&quot;,str.vec,value=TRUE)       # no error, just a zero-length vector NOTE: a very useful alternative to grep() is grepl(), or “logical grep”: instead of returning vector elements or the values themselves, it returns TRUE if there is a match, and FALSE otherwise. grepl(&quot;(time|fruit) flies&quot;,str.vec) We use square brackets when we want to specify a range of possible matching characters: “[abcde]” means “look for any string that contains a, b, c, d, or e” (case sensitive!) “[a-e]” means the same thing; the dash denotes a range “[^a-e]” means “look for any string that contain characters other than a, b, c, d, or e” “[1-4][2-6]” matches strings that contain the numbers 12-16, 22-26, 32-36, or 42-46 str.vec &lt;- c(&quot;I am 18 years old&quot;,&quot;I turned 24 yesterday&quot;,&quot;His age is 112&quot;) grep(&quot;[w-z]&quot;,str.vec,value=TRUE) grep(&quot;[^w-z]&quot;,str.vec,value=TRUE) grep(&quot;[1-4][2-6]&quot;,str.vec,value=TRUE) Note: do not use, e.g., “[2020]” to try to match the year 2020! This actually will match any string that has 2, 0, 2, or 0, or stated more concisely, 0 and 2, in it. Thus it will match with “2020” and “2002” and “2200” and “2345” and “0135”, etc. Other ways to specify particular character types include: “[[:alnum:]]”, which is the same as “[a-zA-Z0-9]” “[[:punct:]]”, which means “match any string that contains a punctuation mark” “[[:space:]]”, which means “match any string that contains a space, a tab, or a new line” “.”, which matches anything (and so is meaningless unless applied as in, e.g., “(a|b).(c|d)”) str.vec &lt;- c(&quot;R2D2&quot;,&quot;r2d2&quot;,&quot;R2 D2&quot;,&quot;R2-D2&quot;) grep(&quot;[A-Z][0-9]&quot;,str.vec,value=TRUE) grep(&quot;[[:space:]]&quot;,str.vec,value=TRUE) grep(&quot;[[:punct:]]&quot;,str.vec,value=TRUE) See ?regex for more possibilities. Metacharacters are strings that are not to be intrepreted literally! The symbols . $ ^ * + ?  | { } [ ] ( ) are all metacharacters. To find occurrences of these symbols in strings, we need to use an escape sequence: we place a backslash in front of the symbol. (Note that in searches we have to double the number of backslashes because the backslash itself is a metacharacter!) str.vec &lt;- c(&quot;que?&quot;,&quot;these symbols-[ and ]-are square brackets&quot;,&quot;:)&quot;,&quot;:-&gt;&quot;) grep(&quot;\\\\?&quot;,str.vec,value=TRUE) grep(&quot;\\\\]&quot;,str.vec,value=TRUE) grep(&quot;:\\\\)&quot;,str.vec,value=TRUE) grep(&quot;&gt;&quot;,str.vec,value=TRUE) Note: a single backslash in any string will not be interpreted as a single backslash, but rather as a backslash plus whatever character follows it. (For example, you cannot search for the backslash in the string \"\\n\" because to R, the backslash and the “n” are implicitly combined together into a single entity that means “line break”.) Quantifiers in regexes allow us greater flexibility is searches. “+” means “occurs 1 or more times” “*” means “occurs 0 or more times” “?” means “the preceding regex is optional”…it differs from “*” in that “?” means “occurs 0 or 1 time” only “{n}”, “{n,}”, and “{n,m}” mean “exactly n”, “n or more”, and “between n and m inclusive” times; note that these only work in the way you’d expect in combination with other regexes A quantifier’s scope is what it is applied to. By default, the scope is the character preceding the quantifier. If you wish to have the quantifier apply to an entire group of characters, place parantheses around those characters. str.vec &lt;- c(&quot;a&quot;,&quot;ab&quot;,&quot;ac&quot;,&quot;bc&quot;,&quot;cb&quot;,&quot;abb?&quot;,&quot;abab&quot;,&quot;10&quot;,&quot;100&quot;,&quot;1000&quot;) grep(&quot;ab+&quot;,str.vec,value=TRUE) grep(&quot;ab*&quot;,str.vec,value=TRUE) grep(&quot;bc?&quot;,str.vec,value=TRUE) grep(&quot;bc?\\\\?&quot;,str.vec,value=TRUE) grep(&quot;10{1,2}&quot;,str.vec,value=TRUE)         # doesn&#39;t actually match just 10 and 100 Admittedly, this last one is a bit confusing. Think of it as asking whether there is a “10” or a “100” in the string. “1000” has both a “10” and a “100”. You have to add more to the regex to limit the matches to the strings “10” and “100” only. See, e.g., the concept of anchoring below. grep(&quot;(ab)+&quot;,str.vec,value=TRUE) grep(&quot;(ab){2}&quot;,str.vec,value=TRUE) grep(&quot;(00){2}&quot;,str.vec,value=TRUE) When ^ is used outside of square brackets, it means we will only look for the match at the beginning of the string. (It “anchors” the search to the beginning of the string.) str.vec &lt;- c(&quot;Win!&quot;,&quot;winner&quot;,&quot;I win.&quot;) grep(&quot;^[Ww]in&quot;,str.vec,value=TRUE) Similarly, “$” looks for a match only at the end of the string. str.vec &lt;- c(&quot;WIN&quot;,&quot;win&quot;,&quot;Winner winner chicken dinner&quot;) grep(&quot;[Nn]$&quot;,str.vec,value=TRUE) str &lt;- &quot;keep ... on ....swimming... swimming.......swimming...&quot; strsplit(str,split=&quot; *\\\\.+ *&quot;)       # 0+ spaces followed by 1+ periods followed by 0+ spaces Note that the output of strsplit() is a list. Here, the input is a single string, so the output list has only one element that contains the split vector of strings. In cases like this, applying unlist() can be helpful. str &lt;- &quot;keep on swimming; swimming;  swimming;   swimming&quot; unlist(strsplit(str,split=&quot;;? +&quot;))   # optional semi-colon followed by 1+ spaces 3.2.1 Regular Expressions: Lab Exercises Please download and work through the following R Markdown file: regex.Rmd The solutions are provided here. 3.3 String Extraction and Replacement Let’s say that instead of receiving an entire string that contains a matching substring, which is what you would receive if you use grep() with value=TRUE, you just want that substring. To get just the substring, use a combination of regexpr() and regmatches(): regexpr() returns the location of the first match in the target string (or -1 if no match is found); and regmatches() takes the output of regexpr() and returns the matching substring. An example of string extraction: str.vec &lt;- c(&quot;abccc&quot;,&quot;ababc&quot;,&quot;cabcc&quot;,&quot;ccabb&quot;,&quot;ccccc&quot;) reg.exp &lt;- regexpr(&quot;ab+&quot;,str.vec,useBytes=TRUE) reg.exp regmatches(str.vec,reg.exp) The first line of output tells you where in the string the match occurs, and that the match.length attribute tells you the length of the matching substring in characters. You can also use regmatches() to specify a replacement for these substrings: regmatches(str.vec,reg.exp) &lt;- &quot;xy&quot; str.vec Notice that in the second string, only the first instance of “ab” is replaced. Again, as we have been using it up to now, regexpr() will only return the first matching substring. To get all the matching substrings in a given string, use gregexpr(): str.vec &lt;- c(&quot;abab&quot;,&quot;abAB&quot;,&quot;ABAB&quot;,&quot;ccAbCC&quot;) greg.exp &lt;- gregexpr(&quot;ab|AB&quot;,str.vec) regmatches(str.vec,greg.exp)                # returns a list, one element per input string regmatches(str.vec,greg.exp) &lt;- &quot;xy&quot; str.vec As an alternative, we can use sub() and gsub(): str.vec &lt;- c(&quot;abab&quot;,&quot;abAB&quot;,&quot;ABAB&quot;,&quot;ccAbCC&quot;) sub(&quot;ab|AB&quot;,&quot;xy&quot;,str.vec)                   # sub(): replace first occurrence of matching substring str.vec Note that unlike before, the original string vector is not itself changed! If you need, e.g., to compare how your initial and final strings appear, sub() or gsub() is the way to go. The difference: sub() replaces the first occurrence of the matching substring, while gsub() replaces all occurrences of the matching substring. str.vec &lt;- c(&quot;abab&quot;,&quot;abAB&quot;,&quot;ABAB&quot;,&quot;ccAbCC&quot;) gsub.out &lt;- gsub(&quot;ab|AB&quot;,&quot;xy&quot;,str.vec) gsub.out 3.3.1 String Extraction and Replacement: Lab Exercises Please download and work through the following R Markdown file: string_extraction.Rmd The solutions are provided here. "],["data-frames-and-data-manipulation.html", "4 Data Frames and Data Manipulation 4.1 Data I/O 4.2 Split/Apply/Combine 4.3 Pipes 4.4 Data Manipulation with dplyr", " 4 Data Frames and Data Manipulation 4.1 Data I/O The data input and output functions that are provided here are those of what we would call “base R.” Simply note for now that there is more data I/O functionality available through the tidyverse package. If your data file is an ASCII (i.e., human-readable) text file… then you will generally use read.table() or read.csv(). read.table(): used with data whose values are separated by spaces read.csv(): used when you have “comma-separated values” Other alternatives include read.delim() and scan() (for more general formats), along with readLines() (which simply reads each line of a file into an element of a character vector). We won’t go into binary (i.e., non-human-readable) files, as how to read in their data can be highly domain specific. To get a handle on how you might proceed if a binary reader has not already been coded for you, see the help page for connections. Beware the arguments! header provides column names, and is FALSE by default for read.table() stringsAsFactors is default TRUE and will lead to your character string vector being treated as a factor variable na.strings is NA by default, but beware: domain scientists use many symbols and/or numbers to indicate that data are missing (like -99) Other important arguments: skip: if there are lines of metadata preceding the first line of data, use skip to skip over them. nrows: instead of reading the whole file, read in this many rows only Side effects: If your column name has white spaces, read.table() and read.csv() will fill them in with periods. As you might expect, read.table() and read.csv() have analogous write functions: write.table() and write.csv(). The two main arguments to look out for are: quote: default TRUE…it puts double quotes around your column (and row) names. Set this to FALSE. row.names: default TRUE…which means, if you don’t have row names in your data frame, you’ll have “1”, “2”, etc. as the row names in your output. Also set this to FALSE if you don’t have row names already. One can save R objects (vectors, data frames, etc.) in a binary format, so as to be loaded later: x &lt;- 5 y &lt;- list(a=1:2,b=TRUE) save(x,y,file=&quot;tmp.Rdata&quot;) rm(x,y) gc() load(&quot;tmp.Rdata&quot;) x y Note the following: The suffixes .Rdata and .Rda are interchangable There is a saveRDS() function which saves one R object in a file with suffix .Rds…this object may be given a new name when read in with readRDS() 4.1.1 Data I/O: Lab Exercises Please download and work through the following R Markdown file: data_io.Rmd The solutions are provided here. To complete the lab, you will need to download the following datasets: emline.csv, simple.txt, students.csv, and students.txt. 4.2 Split/Apply/Combine The split-apply-combine paradigm is straightforward: you take a data frame that contains one or more columns with factor variables (i.e., data measured in categories), and split it, e.g., break the data frame up into a list of smaller data frames, one for each factor or combination of factors; apply a function to each of the smaller data frames; and combine the results together. (Note that there is no explicit “combine” function in R, per se; combination often “just occurs” as a by-product of application.) One can do this with base R functions, although there are some limitations that can crop up from time to time. (See, e.g., this paper in the Journal of Statistical Software. Thus after discussing typical base R functions we will begin venturing into the tidyverse, to talk about dplyr, etc. Above, we use the word “factors.” It is inevitable that in statistical analyses you will at some point have to deal with factors: variables with discrete values that often do not clearly map to the real number line. For instance, the state dataset (part of R’s datasets package) includes state.region, which labels each state with the region of the U.S. it is in: state.region Note that there are four (not five) levels for this factor: “Northeast,” “South,” “North Central,” and “West.” levels(state.region) How are factor variables treated in regression? As numbers, counting from one. typeof(state.region)  # R views the factors as integers, not words class(state.region)   # ...and it knows the factors are factors levels(state.region)  # The levels are 1, 2, 3, ... from left to right as.numeric(state.region) The base-R split() function splits up the rows of a data frame (or elements of a vector) according to the levels of one or more factors. Usage: split(df,f=my.index), where df is a data frame (vectors are allowed too) and my.index specifies the factor variable(s). The output is a list of data frames (or vectors). galaxy.df = read.table(&quot;http://www.stat.cmu.edu/~pfreeman/GalaxyStatistics.txt&quot;,header=TRUE,                        stringsAsFactors=TRUE) dim(galaxy.df)           # a field and two statistics for 8358 galaxies levels(galaxy.df$Field)  # IDs of the five fields galaxy.split &lt;- split(galaxy.df,f=galaxy.df$Field) typeof(galaxy.split) names(galaxy.split) head(galaxy.split[[1]],5)  # let&#39;s look at the first list component The apply() function works as follows: apply(&lt;data frame/matrix&gt;,MARGIN=&lt;dim&gt;,FUN=&lt;function&gt;) &lt;dim&gt; = 1 for rows, 2 for columns, etc. The dimensionality is not limited to 2! &lt;function&gt; is an existing R function or one that you write yourself Example: you have a data frame whose two columns contain three random samples from a standard normal and three random samples from a Uniform(0,1) distribution respectively. We determine the range, the mean, and the index of the maximum value in each column… set.seed(101) df &lt;- data.frame(n=rnorm(3),u=runif(3)) apply(df,MARGIN=2,FUN=range) apply(df,MARGIN=2,FUN=mean) apply(df,2,which.max)         # dropping the argument names To apply your own function: define it, then pass it along. Here, let’s define a function that gives the index of the maximum value, and the maximum value itself, along each row of a matrix: mat &lt;- matrix(rnorm(9),nrow=3) my.fun &lt;- function(x) { return(c(which.max(x),max(x))) }  # Note: x is the row/column of interest mat apply(mat,1,my.fun) Note: if my.fun() returns \\(k\\) separate values, then the output will have \\(k\\) rows, regardless of the value for MARGIN. When MARGIN=2, that’s generally OK, but when it equals 1 you might want to transpose your output to create something more easily interpreted: t(apply(mat,1,my.fun))  # Now each row of output corresponds to a row of input You need not define the function before the call to apply(): t(apply(mat,1,function(x){c(which.max(x),max(x))})) Up until now, the functions that are passed to apply() have a single argument (or only need to have a single argument specified, with the rest having default values), usually given as x. If you need to specify additional arguments for the function, specify them in the call to apply(): mat &lt;- matrix(runif(100),10,10) apply(mat,1,mean)               # compute row means apply(mat,1,mean,trim=0.1)      # compute 10% trimmed means for each row To review: if my.fun() returns a single value, apply() will return a vector of values, one for each row of input if MARGIN = 1, or each column of input if MARGIN = 2 if my.fun() returns a vector of values of length \\(k\\), apply() will return a \\(k \\times n\\) matrix, where \\(n\\) is the number of rows (or columns) of input if MARGIN = 1 (or 2)…you may need to transpose the output with t() to more easily interpret it, if MARGIN = 1 if my.fun() returns vectors of differents lengths for each input row (or column), the output of apply() will be a list of length the number of rows (or columns) if my.fun() returns a list for each input row (or column), the output of apply() will be a list of lists of length the number of rows (or columns) However, don’t use apply() to do everything. There are optimized functions that allow one to compute… sums along rows (or columns): rowSums() (or colSums()) means along rows (or columns): rowMeans() (or colMeans()) the position of the maximum value along each row of a matrix: max.col() 4.2.1 Split/Apply/Combine: Lab Exercises Please download and work through the following R Markdown file: split_apply.Rmd The solutions are provided here. 4.3 Pipes The tidyverse, which contain variants of split-apply-combine functions existing outside of base R, relies on so-called “pipes.” What do we need to know about pipes? tidyverse functions perform at their best when strung together using the pipe operator. The pipe operator is %&gt;%. NOTE: use ctrl + shift + m as an RStudio shortcut. The pipe operator actually comes from the magrittr package (automatically loaded with the tidyverse), so it can be used on its own, completely independently of the rest of the tidyverse. But what does a pipe do? It takes the return value from one function call and automatically feeds it in as an input to another function. Note that at the Unix command line, for instance, we also have pipes, as in: ls -l | grep tidy | wc -l This lists all the files in the present directory, selects those with the string “tidy” in them, then determines word counts for just those files. Normally you would just load the entire tidyverse, but just to make the point that the magrittr package is the one with the pipe, and that the pipe can be used with non-tidyverse functions, we’ll load magrittr alone. # install the package if it doesn&#39;t exist... # require() will load it if it is there as a side-effect if ( require(magrittr) == FALSE ) {   install.packages(&quot;magrittr&quot;,repos=&quot;https://cloud.r-project.org&quot;)   library(magrittr) } We can write exp(1) with pipes as 1 %&gt;% exp(), and log(exp(1)) as 1 %&gt;% exp() %&gt;% log() exp(1) 1 %&gt;% exp() # actually, you don&#39;t even need the parantheses if there was to be only one argument 1 %&gt;% exp %&gt;% log Passing a single argument through pipes, we interpret something like: x %&gt;% f %&gt;% g %&gt;% h # don&#39;t code this! it is a visual example as h(g(f(x))). So, in your mind, when you see %&gt;%, you should say “and then.” To pass a single value x to a function that has, e.g., two arguments (x and y), you would write x %&gt;% f(y) # don&#39;t code this either!  Here, x is assumed to be the first argument of f(), and y the second. Later we will see how to generalize this so that x need not be the first argument of f(). See if you can interpret the command below without running it, then run it in your R console to check your understanding: mtcars %&gt;% head(4) %&gt;% View (Note: mtcars is one of the many datasets that are included in the base-R environment. To see a list of all of the datasets, use library(help=\"datasets\").) The answer: it takes the data frame mtcars (32 rows, 11 columns), extracts the first four rows, then passes those four rows to a viewer. What’s the “old school” (i.e., base R) way of doing this? View(head(mtcars,4)) Notice that, with pipes: your code is more easily read and interpreted (arguably); and you can run partial commands more easily (which is helpful for debugging). The command x %&gt;% f(y) can be equivalently written in dot notation as: x %&gt;% f(.,y) # and don&#39;t code this What’s the advantage of using dots? Sometimes you want to pass in a variable as the second or third (meaning, not first) argument to a function, with a pipe. As in… x %&gt;% f(y,.) # nor this which is equivalent to evaluating f(y,x). Again, see if you can interpret the code below without running it, then run it in your R console as a way to check your understanding: x &lt;- seq(-2*pi,2*pi,len=1000) x %&gt;% sin %&gt;% abs %&gt;% plot(x,.,typ=&quot;l&quot;) 4.3.1 Pipes: Lab Exercises Please download and work through the following R Markdown file: pipes.Rmd The solutions are provided here. 4.4 Data Manipulation with dplyr To make sense of this set of slides, think of data frames as nouns and dplyr functions as verbs, actions that you apply to manipulate the data frames. Here, we will learn the following dplyr verbs: slice(): subset rows based on integer indexing filter(): subset rows based on logical criteria select(): select certain columns arrange(): order rows by value of a column rename(): rename columns mutate(): create new columns mutate_at(): apply a function to given columns Calling dplyr verbs always outputs a new data frame; it does not alter the existing data frame. To save the new data frame, simply assign it to a variable, as in df.new &lt;- df %&gt;% ... or df %&gt;% ... -&gt; df.new. So to keep the changes, we have to reassign the data frame to be the output of the pipe, as we will see below. To load the tidyverse… # install the package if it doesn&#39;t exist... # require() will load it if it is there as a side-effect if ( require(tidyverse) == FALSE ) {   install.packages(&quot;tidyverse&quot;,repos=&quot;https://cloud.r-project.org&quot;)   suppressWarnings(library(tidyverse)) } Use slice() when you want to indicate certain row numbers need to be kept: mtcars %&gt;% slice(c(7,8,14:15)) # Compare with base R: mtcars[c(7,8,14:15),] Slicing can also be done “negatively”: mtcars %&gt;% slice(-c(1:2,19:23)) %&gt;% nrow() Use filter() when you want to subset rows based on logical conditions: mtcars %&gt;% filter(., (mpg &gt;= 14 &amp; disp &gt;= 200) | (drat &lt;= 3)) %&gt;% head(., 2) # Base R: # head(subset(mtcars, (mpg &gt;= 14 &amp; disp &gt;= 200) | (drat &lt;= 3)), 2) # head(mtcars[(mtcars$mpg &gt;= 14 &amp; mtcars$disp &gt;= 200) | (mtcars$drat &lt;= 3),], 2) Use select() when you want to pick out certain columns: mtcars %&gt;% select(., cyl, disp, hp) %&gt;% head(., 2) # Base R: # head(mtcars[, c(&quot;cyl&quot;, &quot;disp&quot;, &quot;hp&quot;)], 2) Very handy selections using dplyr helper functions: mtcars %&gt;% select(., starts_with(&quot;d&quot;)) %&gt;% head(., 2) # Base R (yikes!): # d_colnames &lt;- grep(x = colnames(mtcars), pattern = &quot;^d&quot;) # head(mtcars[, d_colnames], 2) We can do many other things as well: mtcars %&gt;% select(., ends_with(&#39;t&#39;)) %&gt;% head(., 2) mtcars %&gt;% select(., ends_with(&#39;yl&#39;)) %&gt;% head(., 2) mtcars %&gt;% select(., contains(&#39;ar&#39;)) %&gt;% head(., 2) Use arrange() to order rows by values of a column: mtcars %&gt;% arrange(., desc(drat)) %&gt;% select(., mpg, disp, drat) %&gt;% head(., 2) # Base R: # drat_inds &lt;- order(mtcars$drat, decreasing=TRUE) # head(mtcars[drat_inds, c(&quot;mpg&quot;, &quot;disp&quot;, &quot;drat&quot;)], 2) We can order by multiple columns too: mtcars %&gt;% arrange(., desc(gear), desc(hp)) %&gt;% select(., gear, hp, everything()) %&gt;% head(., 8) Here, we arrange first in order of gear (decreasing); then, for each unique value of gear, we arrange in order of hp (decreasing). Use mutate() when you want to create one or several columns: mtcars = mtcars %&gt;% mutate(., hp_wt = hp/wt, mpg_wt = mpg/wt) # Base R: # mtcars$hp_wt &lt;- mtcars$hp/mtcars$wt # mtcars$mpg_wt &lt;- mtcars$mpg/mtcars$wt Use mutate_at() when you want to apply a function to one or several columns: mtcars &lt;- mtcars %&gt;% mutate_at(., c(&quot;hp_wt&quot;, &quot;mpg_wt&quot;), log) # Base R: # mtcars$hp_wt &lt;- log(mtcars$hp_wt) # mtcars$mpg_wt &lt;- log(mtcars$mpg_wt) NOTE: again, calling mutate_at() outputs a new data frame and does not alter the given data frame, so to keep the column transformations, we have to reassign mtcars to be the output of the pipe! Use rename() to easily rename columns: mtcars %&gt;% rename(., hp_wt_log=hp_wt, mpg_wt_log=mpg_wt) %&gt;% head(., 2) # Base R: # colnames(mtcars)[colnames(mtcars)==&quot;hp_wt&quot;] &lt;- &quot;hp_wt_log&quot; # colnames(mtcars)[colnames(mtcars)==&quot;mpg_wt&quot;] &lt;- &quot;mpg_wt_log&quot; # head(mtcars, 2) 4.4.1 Data Manipulation with dplyr: Lab Exercises Please download and work through the following R Markdown file: dplyr.Rmd The solutions are provided here. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
